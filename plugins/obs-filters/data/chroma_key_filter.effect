uniform float4x4 ViewProj;
uniform texture2d image;

uniform float4x4 yuv_mat = { 0.182586,  0.614231,  0.062007, 0.062745,
                            -0.100644, -0.338572,  0.439216, 0.501961,
                             0.439216, -0.398942, -0.040274, 0.501961,
                             0.000000,  0.000000,  0.000000, 1.000000};

uniform float4 color;
uniform float contrast;
uniform float brightness;
uniform float gamma;

uniform float4 chroma_key;
uniform float2 pixel_size;
uniform float similarity;
uniform float smoothness;
uniform float spill;
uniform int color_space;

sampler_state textureSampler {
	Filter    = Linear;
	AddressU  = Clamp;
	AddressV  = Clamp;
};

struct VertData {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

VertData VSDefault(VertData v_in)
{
	VertData vert_out;
	vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv  = v_in.uv;
	return vert_out;
}

float RGBToXYZChannel(float c)
{
	return c > 0.04045 ? pow((c + 0.055) / 1.055, 2.4) : c / 12.92;
}

float3 RGBToXYZ(float3 rgb)
{
	rgb.r = RGBToXYZChannel(rgb.r);
	rgb.g = RGBToXYZChannel(rgb.g);
	rgb.b = RGBToXYZChannel(rgb.b);

	const float3x3 RGBToXYZMatrix = float3x3(
		0.4124564, 0.3575761, 0.1804375,
		0.2126729, 0.7151522, 0.0721750,
		0.0193339, 0.1191920, 0.9503041);

	return 100.0 * mul(rgb, RGBToXYZMatrix);
}

float XYZToLABChannel(float c)
{
    return c > 0.008856 ? pow(c, 1.0 / 3.0) : (7.787 * c) + (16.0 / 116.0);
}

float3 XYZToLAB(float3 xyz)
{
	const float3 WhiteBalance = float3(95.047, 100, 108.883);
    xyz /= WhiteBalance;

	const float FY = XYZToLABChannel(xyz.y);

	const float L = (116.0 * FY) - 16.0;
	const float A = 500.0 * (XYZToLABChannel(xyz.x) - FY);
	const float B = 200.0 * (FY - XYZToLABChannel(xyz.z));

	return float3(L, A, B);
}

#define epsilon 1e-10

#define kL 1.0
#define kC 1.0
#define kH 1.0

#define deg6InRad   0.10472
#define deg25InRad  0.436332
#define deg30InRad  0.523599
#define deg63InRad  1.09956
#define deg180InRad 3.14159
#define deg275InRad 4.79966
#define deg360InRad 6.28319

#define pow25To7 6103515625.0

float CIEDE2000_distance(float3 one, float3 two)
{
	const float L1 = one.x;
	const float a1 = one.y;
	const float b1 = one.z;

	const float L2 = two.x;
	const float a2 = two.y;
	const float b2 = two.z;

	const float C1 = sqrt((a1 * a1) + (b1 * b1));
	const float C2 = sqrt((a2 * a2) + (b2 * b2));
	const float CBar = 0.5 * (C1 + C2) ;

	const float G = 0.5 * (1 - sqrt(pow(CBar, 7) / (pow(CBar, 7) + pow25To7)));
	const float a1Prime = (1.0 + G) * a1;
	const float a2Prime = (1.0 + G) * a2;

	const float C1Prime = sqrt((a1Prime * a1Prime) + (b1 * b1));
	const float C2Prime = sqrt((a2Prime * a2Prime) + (b2 * b2));

	float h1Prime;
	if (abs(b1) < epsilon && abs(a1Prime) < epsilon)
	{
		h1Prime = 0.0;
	}
	else
	{
		h1Prime = atan2(b1, a1Prime);
		if (h1Prime < 0)
			h1Prime += deg360InRad;
	}

	float h2Prime;
	if (abs(b2) < epsilon && abs(a2Prime) < epsilon)
	{
		h2Prime = 0.0;
	}
	else
	{
		h2Prime = atan2(b2, a2Prime);
		if (h2Prime < 0)
			h2Prime += deg360InRad;
	}

	const float deltaLPrime = L2 - L1;
	const float deltaCPrime = C2Prime - C1Prime;

	const float CPrimeProduct = C1Prime * C2Prime;
	float deltahPrime;
	if (CPrimeProduct < epsilon)
	{
		deltahPrime = 0;
	}
	else
	{
		deltahPrime = h2Prime - h1Prime;
		if (deltahPrime < -deg180InRad)
		{
			deltahPrime += deg360InRad;
		}
		else if (deltahPrime > deg180InRad)
		{
			deltahPrime -= deg360InRad;
		}
	}

	const float deltaHPrime = 2.0 * sqrt(CPrimeProduct) * sin(deltahPrime * 0.5);

	const float barLPrime = 0.5 * (L1 + L2);
	const float barCPrime = 0.5 * (C1Prime + C2Prime);

	const float hPrimeSum = h1Prime + h2Prime;
	float barhPrime;
	if (C1Prime * C2Prime < epsilon)
	{
		barhPrime = hPrimeSum;
	}
	else
	{
		if (abs(h1Prime - h2Prime) <= deg180InRad)
		{
			barhPrime = 0.5 * hPrimeSum;
		}
		else
		{
			if (hPrimeSum < deg360InRad)
			{
				barhPrime = 0.5 * (hPrimeSum + deg360InRad);
			}
			else
			{
				barhPrime = 0.5 * (hPrimeSum - deg360InRad);
			}
		}
	}

	const float T = 1.0 -
		(0.17 * cos(barhPrime - deg30InRad)) +
	    (0.24 * cos(2.0 * barhPrime)) +
	    (0.32 * cos((3.0 * barhPrime) + deg6InRad)) -
	    (0.20 * cos((4.0 * barhPrime) - deg63InRad));

	const float deltaThetaHalf = (barhPrime - deg275InRad) / deg25InRad;
	const float deltaTheta = deg30InRad * exp(- (deltaThetaHalf * deltaThetaHalf));

	const float RCPartial = pow(barCPrime, 7.0);
	const float RC = 2.0 * sqrt(RCPartial / (RCPartial + pow25To7));

	const float SLPartial = (barLPrime - 50.0) * (barLPrime - 50.0);
	const float SL = 1.0 + ((0.015 * SLPartial) / sqrt(20 + SLPartial));

	const float SC = 1.0 + (0.045 * barCPrime);
	const float SH = 1.0 + (0.015 * barCPrime * T);
	const float RT = (-sin(2.0 * deltaTheta)) * RC;

	const float deltaL = deltaLPrime / (kL * SL);
	const float deltaC = deltaCPrime / (kC * SC);
	const float deltaH = deltaHPrime / (kH * SH);

	const float deltaESquared = (deltaL * deltaL) + (deltaC * deltaC) + (deltaH * deltaH) + (RT * deltaC * deltaH);
	return sqrt(deltaESquared);
}

float GetChromaDist(float3 rgb)
{
	if(color_space == 0)
	{
		float4 yuvx = mul(float4(rgb.rgb, 1.0), yuv_mat);
		float4 chroma_yuvx = mul(float4(chroma_key.rgb, 1.0), yuv_mat);

		return distance(chroma_yuvx.yz, yuvx.yz);
	}

	float3 chroma_key_lab = XYZToLAB(RGBToXYZ(chroma_key.rgb));
	float3 lab = XYZToLAB(RGBToXYZ(rgb));

	if(color_space == 1)
	{
		return distance(chroma_key_lab, lab) / 200.0;
	}

	return CIEDE2000_distance(chroma_key_lab, lab) / 200.0;
}

float4 CalcColor(float4 rgba)
{
	return float4(pow(rgba.rgb, float3(gamma, gamma, gamma)) * contrast + brightness, rgba.a);
}

float4 SampleTexture(float2 uv)
{
	return image.Sample(textureSampler, uv);
}

float GetBoxFilteredChromaDist(float3 rgb, float2 texCoord)
{
	float2 h_pixel_size = pixel_size / 2.0;
	float2 point_0 = float2(pixel_size.x, h_pixel_size.y);
	float2 point_1 = float2(h_pixel_size.x, -pixel_size.y);
	float distVal = GetChromaDist(SampleTexture(texCoord-point_0).rgb);
	distVal += GetChromaDist(SampleTexture(texCoord+point_0).rgb);
	distVal += GetChromaDist(SampleTexture(texCoord-point_1).rgb);
	distVal += GetChromaDist(SampleTexture(texCoord+point_1).rgb);
	distVal *= 2.0;
	distVal += GetChromaDist(rgb);
	return distVal / 9.0;
}

float4 ProcessChromaKey(float4 rgba, VertData v_in)
{
	float chromaDist = GetBoxFilteredChromaDist(rgba.rgb, v_in.uv);
	float baseMask = chromaDist - similarity;
	float fullMask = pow(saturate(baseMask / smoothness), 1.5);
	float spillVal = pow(saturate(baseMask / spill), 1.5);

	rgba.rgba *= color;
	rgba.a *= fullMask;

	float desat = (rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722);
	rgba.rgb = saturate(float3(desat, desat, desat)) * (1.0 - spillVal) + rgba.rgb * spillVal;

	return CalcColor(rgba);
}

float4 PSChromaKeyRGBA(VertData v_in) : TARGET
{
	float4 rgba = image.Sample(textureSampler, v_in.uv);
	return ProcessChromaKey(rgba, v_in);
}

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = PSChromaKeyRGBA(v_in);
	}
}
